name: "Deploy QT6 WebAssembly Project"

on:
  workflow_dispatch:  # Allow manual trigger
  push:
    branches:
      - main  # Updated to use main instead of master
      - master  # Keep master as fallback

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libgl1-mesa-dev libglib2.0-dev libfontconfig1-dev libxkbcommon-x11-dev

      - name: Install Emscripten
        uses: mymindstorm/setup-emsdk@v12
        with:
          version: '3.1.37'
          actions-cache-folder: 'emsdk-cache'
      
      - name: Verify Emscripten installation
        run: |
          emcc --version
          em++ --version
      
      - name: Setup Qt
        uses: jurplel/install-qt-action@v3
        with:
          version: '6.5.3'  # Using more recent version
          host: 'linux'
          target: 'desktop'
          arch: 'wasm_32'
          tools: 'tools_webassembly'
          cache: true
      
      - name: Configure environment
        run: |
          echo "PATH=$PATH:$EMSDK/upstream/emscripten" >> $GITHUB_ENV
          echo "EMSCRIPTEN=$EMSDK/upstream/emscripten" >> $GITHUB_ENV
          source $EMSDK/emsdk_env.sh
          env | grep EM
      
      - name: Debug project structure
        run: |
          pwd
          ls -la
          find . -type f -name "*.pro" -o -name "CMakeLists.txt"
      
      - name: Detect build system
        id: detect-build
        run: |
          if [ -f "CMakeLists.txt" ]; then
            echo "Using CMake build system"
            echo "build_system=cmake" >> $GITHUB_OUTPUT
          elif [ -f "*.pro" ]; then
            echo "Using QMake build system"
            echo "build_system=qmake" >> $GITHUB_OUTPUT
          else
            echo "No recognized build system found"
            find . -type f | grep -E '\.(pro|cmake|txt)$'
            echo "build_system=unknown" >> $GITHUB_OUTPUT
          fi
      
      - name: Build project with QMake
        if: steps.detect-build.outputs.build_system == 'qmake' || steps.detect-build.outputs.build_system == 'unknown'
        run: |
          mkdir -p build
          cd build
          
          # Find the first .pro file
          PRO_FILE=$(find .. -type f -name "*.pro" | head -n 1)
          
          if [ -z "$PRO_FILE" ]; then
            echo "No .pro file found. Creating simple test project."
            cat > ../test.pro << 'EOL'
            QT += core gui widgets
            CONFIG += c++17
            TARGET = testapp
            TEMPLATE = app
            SOURCES += main.cpp
            EOL
            
            cat > ../main.cpp << 'EOL'
            #include <QApplication>
            #include <QLabel>
            int main(int argc, char *argv[]) {
                QApplication app(argc, argv);
                QLabel label("Hello WebAssembly World!");
                label.resize(300, 100);
                label.show();
                return app.exec();
            }
            EOL
            
            PRO_FILE="../test.pro"
          fi
          
          echo "Building project: $PRO_FILE"
          qmake $PRO_FILE WASM_OBJECT_FILES=1
          make -j$(nproc)
          
          echo "Build directory contents:"
          ls -la
      
      - name: Build project with CMake
        if: steps.detect-build.outputs.build_system == 'cmake'
        run: |
          mkdir -p build
          cd build
          cmake -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake ..
          cmake --build . --parallel
          
          echo "Build directory contents:"
          ls -la
      
      - name: Create web directory structure
        run: |
          mkdir -p web-build
          
          # Create a proper index.html if it doesn't exist in the build directory
          if [ ! -f "build/index.html" ]; then
            cat > web-build/index.html << 'EOL'
            <!DOCTYPE html>
            <html>
            <head>
              <meta charset="utf-8">
              <title>QT6 WebAssembly Project</title>
              <style>
                body { margin: 0; background-color: #f0f0f0; font-family: Arial, sans-serif; }
                #qtspinner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
                #qtlogo { background: url("qtlogo.svg") no-repeat center center; width: 200px; height: 200px; }
                #qtstatus { margin-top: 30px; font-size: 14px; text-align: center; }
                #qtfooter { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 12px; }
                #qt_loadingScreen { width: 100vw; height: 100vh; position: relative; }
              </style>
              <script src="qtloader.js"></script>
            </head>
            <body>
              <div id="qt_loadingScreen">
                <div id="qtspinner">
                  <div id="qtlogo"></div>
                  <div id="qtstatus">Loading...</div>
                </div>
              </div>
              <div id="qtfooter">QT6 WebAssembly Demo</div>
              <script>
                const appName = Object.keys(window).find(key => key.endsWith('_js'));
                const loaderScript = document.createElement('script');
                
                if (appName) {
                  loaderScript.src = appName + ".js";
                  document.body.appendChild(loaderScript);
                } else {
                  // Fallback to find any .js file that might be our app
                  fetch('./').then(response => response.text()).then(text => {
                    const parser = new DOMParser();
                    const htmlDoc = parser.parseFromString(text, 'text/html');
                    const links = Array.from(htmlDoc.querySelectorAll('a'));
                    const jsFile = links.find(link => link.href.endsWith('.js') && !link.href.includes('qtloader.js'));
                    
                    if (jsFile) {
                      loaderScript.src = jsFile.href.split('/').pop();
                      document.body.appendChild(loaderScript);
                    } else {
                      document.getElementById('qtstatus').textContent = 'Error: No application found.';
                    }
                  });
                }
              </script>
            </body>
            </html>
            EOL
          else
            cp build/index.html web-build/
          fi
      
      - name: Find and copy WebAssembly build files
        run: |
          # Copy standard web files
          cp -r build/*.js web-build/ 2>/dev/null || true
          cp -r build/*.wasm web-build/ 2>/dev/null || true
          cp -r build/*.html web-build/ 2>/dev/null || true
          cp -r build/*.svg web-build/ 2>/dev/null || true
          cp -r build/*.data web-build/ 2>/dev/null || true
          cp -r build/*.worker.js web-build/ 2>/dev/null || true
          cp -r build/qtloader.js web-build/ 2>/dev/null || true
          
          # Create qtlogo.svg if it doesn't exist
          if [ ! -f "web-build/qtlogo.svg" ]; then
            cat > web-build/qtlogo.svg << 'EOL'
            <svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 190 190">
              <path fill="#41cd52" d="M86.61 0L0 49.99v30.01l49.99-28.87v68.76L86.61 100V0z"/>
              <path fill="#41cd52" d="M190 49.99L103.39 0v100l36.62 19.89v-68.76L190 80V49.99z"/>
              <path fill="#41cd52" d="M53.63 126.23l-49.99 28.87v-30.01l49.99-28.87v30.01zM140.01 126.23l49.99 28.87v-30.01l-49.99-28.87v30.01z"/>
              <path fill="#41cd52" d="M53.63 190l49.98 28.87V154.21L66.86 134.62l-13.23 7.61V190z"/>
              <path fill="#41cd52" d="M140.01 190l-49.98 28.87V154.21l36.75-19.59 13.23 7.61V190z"/>
            </svg>
            EOL
          fi
          
          # If the build directory is empty, create a simple WebAssembly demo
          if [ ! "$(ls -A web-build)" ] || [ "$(ls -A web-build | wc -l)" -le "2" ]; then
            echo "No build files found. Creating simple WebAssembly demo..."
            cat > web-build/demo.js << 'EOL'
            var Module = {
              onRuntimeInitialized: function() {
                document.getElementById('qtstatus').textContent = 'WebAssembly loaded successfully!';
                document.getElementById('qtspinner').innerHTML += '<p>This is a placeholder for your QT WebAssembly app.</p><p>Please check your build configuration.</p>';
              },
              print: function(text) {
                console.log(text);
              },
              printErr: function(text) {
                console.error(text);
              }
            };
            EOL
            
            cat > web-build/qtloader.js << 'EOL'
            function showError(message) {
              document.getElementById('qtstatus').innerHTML = 'Error: ' + message;
            }
            
            window.onload = function() {
              setTimeout(function() {
                document.getElementById('qtstatus').textContent = 'Demo mode - no actual WebAssembly app found';
              }, 1000);
            };
            EOL
          fi
          
          echo "Contents of web-build directory:"
          ls -la web-build/
      
      - name: Setup GitHub Pages
        uses: actions/configure-pages@v3
      
      - name: Upload GitHub Pages artifact
        uses: actions/upload-pages-artifact@v2
        with:
          path: web-build
      
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2